{
  "name": "gulp-declare",
  "version": "0.3.0",
  "description": "Safely declare namespaces and set their properties",
  "main": "index.js",
  "dependencies": {
    "vinyl-map": "^1.0.1",
    "xtend": "^4.0.0",
    "nsdeclare": "^0.1.0"
  },
  "devDependencies": {
    "gulp-util": "^3.0.0",
    "should": "^4.0.4",
    "mocha": "^1.21.4"
  },
  "scripts": {
    "test": "./node_modules/.bin/mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/lazd/gulp-declare.git"
  },
  "keywords": [
    "gulpplugin",
    "declare"
  ],
  "author": {
    "name": "Larry Davis",
    "email": "lazdnet@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/lazd/gulp-declare/issues"
  },
  "engines": {
    "node": ">=0.10"
  },
  "readme": "# gulp-declare [![NPM version][npm-image]][npm-url] [![Build status][travis-image]][travis-url]\n> declare plugin for gulp 3\n\n## Usage\n\nFirst, install `gulp-declare` as a development dependency:\n\n```shell\nnpm install --save-dev gulp-declare\n```\n\nThen, add it to your `gulpfile.js`:\n\n```javascript\nvar declare = require('gulp-declare');\nvar concat = require('gulp-concat');\n\ngulp.task('models', function() {\n  // Define each model as a property of a namespace according to its filename\n  gulp.src(['client/models/*.js'])\n    .pipe(declare({\n      namespace: 'MyApp.models',\n      noRedeclare: true // Avoid duplicate declarations\n    }))\n    .pipe(concat('models.js')) // Combine into a single file\n    .pipe(gulp.dest('build/js/'));\n});\n```\n\n## API\n\n### declare(options)\n\n#### options.namespace\nType: `String`  \nDefault: `\"this\"`\n\nThe namespace in which the file contents will be assigned. Use dot notation (e.g. `MyApp.templates`) for nested namespaces.\n\nFor example, if the namespace is `MyApp.templates` and a file is named `App.Header.js`, the following declaration will be added:\n\n```javascript\nthis[\"MyApp\"] = this[\"MyApp\"] || {};\nthis[\"MyApp\"][\"templates\"] = this[\"MyApp\"][\"templates\"] || {};\nthis[\"MyApp\"][\"templates\"][\"App\"] = this[\"MyApp\"][\"templates\"][\"App\"] || {};\nthis[\"MyApp\"][\"templates\"][\"App\"][\"Header\"] = /* File contents from App.Header.js */;\n```\n\nIf the default value of `\"this\"` is provided, namespace declaration will be determined soley by the filename and output of `options.processName`. That is, a file names `MyApp.templates.App.Header.js` will result in the same declaration as above.\n\n\n#### options.processName\nType: `Function`  \nDefault: Strip file extension\n\nThis option accepts a function which takes one argument (the path to the file) and returns a string which will be used as the key for object. By default, the filename minus the extension is used.\n\nThis function should return a namespace path in dot notation, such as `Prop.sub.item`, which is then combined with `options.namespace`. See [`options.namespace`](#optionsnamespace) above for an example.\n\nSee [`declare.processNameByPath`](#declareprocessnamebypathfilepath) to generate namespace paths based on directory structure.\n\n#### options.separator\nType: `String`  \nDefault: `\\n`\n\nThe separator to use between declarations.\n\n\n#### options.noRedeclare\nType: `Boolean`  \nDefault: `false`\n\nIf `true`, parts of the namespace that were declared as a result of previous files in the stream will not be redeclared. For instance, if the stream contains the following files:\n\n* Main.Content.js\n* Main.Header.js\n* Main.Footer.js\n\nAnd if `declare` is invoked with `{ namespace: 'MyApp', noRedeclare: true }`, the contents of the streamed files will look like this:\n\n**Main.Content.js**\n```javascript\nthis[\"MyApp\"] = this[\"MyApp\"] || {};\nthis[\"MyApp\"][\"Main\"] = this[\"MyApp\"][\"Main\"] || {};\nthis[\"MyApp\"][\"Main\"][\"Content\"] = /* File contents from Main.Content.js */;\n```\n\n**Main.Header.js**\n```javascript\nthis[\"MyApp\"][\"Main\"][\"Header\"] = /* File contents from Main.Header.js */;\n```\n\n**Main.Footer.js**\n```javascript \nthis[\"MyApp\"][\"Main\"][\"Footer\"] = /* File contents from Main.Footer.js */;\n```\n\nThis option makes the most sense when you're concatenating files later and want to minimize duplicate declarations. Regardless of this option, `gulp-declare` will never clobber existing namespaces or their properties.\n\n#### options.root\nType: `String`  \nDefault: `this`\n\nThe root object to declare the namespace within. Defaults to `this` (which is equal to `window` in the browser).\n\nThis option is prepended to the assignment statement, so special characters or operators such as `-` should be avoided as they will result in an invalid left-hand assignment error.\n\nWhen using Node or Browserify, you can specify `root: 'module.exports'` with no namespace if you would like to assign as properties of an exported module:\n\n```js\ngulp.src(['models/*.js'])\n  .pipe(declare({\n    root: 'module.exports', // Declare as properties of module.exports\n    noRedeclare: true // Avoid duplicate declarations\n  })\n  .pipe(concat('models.js'))\n  .pipe(gulp.dest('build/js/'));\n```\n\nWhich results in the following `templates.js`:\n\n```js\nmodule.exports[\"App\"] = module.exports[\"App\"] || {};\nmodule.exports[\"App\"][\"Main\"] = /* File contents from App.Main.js */;\nmodule.exports[\"App\"][\"Header\"] = /* File contents from App.Header.js */;\nmodule.exports[\"App\"][\"Footer\"] = /* File contents from App.Footer.js */;\n```\n\n### declare.processNameByPath(filePath)\n\nPass this method as `options.processName` so the path within the namespace matches the path in the filesystem combined with dot notation from the filename:\n\n```js\ngulp.src(['templates/**/*.html'])\n  .pipe(domly()) // Compile HTML to document fragment builder functions\n  .pipe(declare({\n    namespace: 'NS', // Use NS as the base namespace\n    noRedeclare: true, // Avoid duplicate declarations\n    processName: declare.processNameByPath // Include the path as part of the sub-namespace\n  })\n  .pipe(concat('models.js'))\n  .pipe(gulp.dest('build/js/'));\n```\n\nThe above configuration will result in the following mapping:\n\n| File path                         | Namespace path                   |\n| --------------------------------- | -------------------------------- |\n| templates/App.hbs                 | NS.templates.App                 |\n| templates/App/header.hbs          | NS.templates.App.header          |\n| templates/App/content.initial.hbs | NS.templates.App.content.initial |\n| templates/Other.item.hbs          | NS.templates.Other.item          |\n\n**Note:** In the above example, `NS.templates.App.header` is a function that is stored as a property of the `NS.templates.App` function. As everything in JavaScript is an object, even functions, this is perfectly valid and works in all environments. If this hurts your brain, store `templates/App.hbs` as `templates/App/main.hbs` and access it as `NS.templates.App.main`.\n\n#### Customizing the path used to generate the namespace\n\nIf you want to remove or change part of the path, you can define your own `options.processName` and use `declare.processNameByPath()` within it. The following example results in the same namespace paths as above with a different directory structure:\n\n```js\ngulp.src(['client/templates/**/*.html'])\n  .pipe(domly()) // Compile HTML to document fragment builder functions\n  .pipe(declare({\n    namespace: 'NS.templates', // Declare within NS.templates\n    noRedeclare: true, // Avoid duplicate declarations\n    processName: function(filePath) {\n      // Drop the client/templates/ folder from the namespace path\n      return declare.processNameByPath(filePath.replace('client/templates/', ''));\n    }\n  })\n  .pipe(concat('templates.js'))\n  .pipe(gulp.dest('build/js/'));\n```\n\n\n[travis-url]: http://travis-ci.org/lazd/gulp-declare\n[travis-image]: https://secure.travis-ci.org/lazd/gulp-declare.png?branch=master\n[npm-url]: https://npmjs.org/package/gulp-declare\n[npm-image]: https://badge.fury.io/js/gulp-declare.png\n",
  "readmeFilename": "README.md",
  "_id": "gulp-declare@0.3.0",
  "_from": "gulp-declare@~0.3.0"
}
